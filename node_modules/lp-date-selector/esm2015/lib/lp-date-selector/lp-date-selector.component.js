import { Component, Input, forwardRef } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';
import { LpDate } from 'lp-operations';
export class LpDateSelectorComponent {
    constructor() {
        this.disabled = false;
        this.monthOptions = ['january', 'february', 'march', 'april', 'may', 'june', 'july', 'august', 'september', 'october', 'november', 'december'];
        this.propagateChange = (_) => { };
    }
    writeValue(date) {
        this.selectedDate = date;
    }
    registerOnChange(fn) { this.propagateChange = fn; }
    registerOnTouched() { }
    setDate(date, year, month) {
        if (date) {
            this.selectedDate = date;
            this.propagateChange(this.selectedDate);
        }
        else if (year.length === 4) {
            this.selectedDate = new Date(Number(year), Number(month), 1, 0, 0, 0, 0);
            this.propagateChange(this.selectedDate);
        }
    }
    monthValue(month) {
        return LpDate.monthValue(month);
    }
}
LpDateSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'lp-date-selector',
                template: "\n\n<div class=\"div-date\" fxLayoutAlign=\"center\" *ngIf=\"dateFormat === 'day'\">\n    <mat-form-field fxFlex=\"100\" appearance=\"fill\">\n        <mat-label>{{label}}</mat-label>\n        <input [min]=\"minDate\" [max]=\"maxDate\" (ngModelChange)=\"setDate($event)\" [disabled]=\"disabled\"  [ngModel]=\"selectedDate\" name=\"date\" #daySelection matInput [matDatepicker]=\"picker\">\n        <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n        <mat-datepicker #picker></mat-datepicker>\n    </mat-form-field>\n</div>\n<div  class=\"div-date\" *ngIf=\"dateFormat === 'month'\" fxLayout.gt-xs=\"row\" fxLayoutAlign=\"center\" fxLayout.xs=\"column\">\n    <mat-form-field fxFlex=\"40\" fxLayoutAlign=\"center\" appearance=\"fill\">\n            <mat-label>Year</mat-label>\n            <input [disabled]=\"disabled\" [min]=\"min ? min.getFullYear():null\" [max]=\"max ? max.getFullYear():null\" (keyup)=\"setDate(null,yearSelection.value, monthSelection.value)\"  #yearSelection [value]=\"selectedDate ? selectedDate.getFullYear().toString() : null\"  matInput\n                onkeypress=\"return event.charCode >= 48 && event.charCode <= 57\" placeholder=\"Year\">\n    </mat-form-field>\n    <mat-form-field fxFlex=\"40\"  fxLayoutAlign=\"center\" appearance=\"fill\">\n            <mat-label>Month</mat-label>\n            <mat-select (selectionChange)=\"setDate(undefined,yearSelection.value, monthSelection.value)\"  #monthSelection [value]=\"selectedDate ? selectedDate.getMonth().toString() : null\"\n                [disabled]=\"!yearSelection.value || disabled\">\n                <mat-option *ngFor=\"let month of monthOptions\" [value]=\"monthValue(month)\">\n                    {{month}}\n                </mat-option>\n            </mat-select>\n     </mat-form-field>\n</div>\n<div  class=\"div-date\" *ngIf=\"dateFormat === 'time'\" fxLayout=\"column\" fxLayoutAlign=\"center\">\n        <label *ngIf=\"label\" for=\"endDate\">{{label}}</label>\n             <input \n                #timeSelection \n                class=\"input-date\"\n                [owlDateTime]=\"dt2\"\n                [owlDateTimeTrigger]=\"dt2\"\n                [disabled]=\"disabled\" \n                [placeholder]=\"placeholder\" \n                (ngModelChange)=\"setDate($event)\"\n                [min]=\"minDate\" \n                [max]=\"maxDate\"\n                required \n                [ngModel]=\"selectedDate\" \n                matInput \n                readonly>\n        <owl-date-time #dt2></owl-date-time>\n</div>\n\n",
                providers: [
                    {
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => LpDateSelectorComponent),
                        multi: true,
                    }
                ],
                styles: [".div-date{margin:5px}.div-date .input-date{cursor:pointer}.div-date mat-form-field{width:200px!important}"]
            },] }
];
LpDateSelectorComponent.ctorParameters = () => [];
LpDateSelectorComponent.propDecorators = {
    dateFormat: [{ type: Input }],
    selectedDate: [{ type: Input }],
    minDate: [{ type: Input }],
    maxDate: [{ type: Input }],
    placeholder: [{ type: Input }],
    label: [{ type: Input }],
    disabled: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibHAtZGF0ZS1zZWxlY3Rvci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiQzovVXNlcnMvMzQ2OTUvRGVza3RvcC9EUkFGVC90ZWFtLW1hbmFnZXItZnJvbnRlbmQvcHJvamVjdHMvbHAtZGF0ZS1zZWxlY3Rvci9zcmMvIiwic291cmNlcyI6WyJsaWIvbHAtZGF0ZS1zZWxlY3Rvci9scC1kYXRlLXNlbGVjdG9yLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDN0QsT0FBTyxFQUF3QixpQkFBaUIsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3pFLE9BQU8sRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFjdkMsTUFBTSxPQUFPLHVCQUF1QjtJQVVsQztRQUZTLGFBQVEsR0FBWSxLQUFLLENBQUM7UUFDbkMsaUJBQVksR0FBRyxDQUFDLFNBQVMsRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsVUFBVSxDQUFDLENBQUE7UUFFakksb0JBQWUsR0FBRyxDQUFDLENBQU0sRUFBRSxFQUFFLEdBQUcsQ0FBQyxDQUFDO0lBRDFCLENBQUM7SUFFVixVQUFVLENBQUMsSUFBVTtRQUMxQixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztJQUMzQixDQUFDO0lBQ00sZ0JBQWdCLENBQUMsRUFBTyxJQUFJLElBQUksQ0FBQyxlQUFlLEdBQUcsRUFBRSxDQUFDLENBQUMsQ0FBQztJQUN4RCxpQkFBaUIsS0FBSyxDQUFDO0lBQzlCLE9BQU8sQ0FBQyxJQUFXLEVBQUUsSUFBYSxFQUFFLEtBQWM7UUFDaEQsSUFBRyxJQUFJLEVBQUM7WUFDTixJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQztZQUN6QixJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQTtTQUN4QzthQUFLLElBQUcsSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUM7WUFDekIsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsTUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUN6RSxJQUFJLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsQ0FBQTtTQUN4QztJQUNILENBQUM7SUFDRCxVQUFVLENBQUMsS0FBYTtRQUN0QixPQUFPLE1BQU0sQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUE7SUFDakMsQ0FBQzs7O1lBeENGLFNBQVMsU0FBQztnQkFDVCxRQUFRLEVBQUUsa0JBQWtCO2dCQUM1Qix3aEZBQWdEO2dCQUVoRCxTQUFTLEVBQUU7b0JBQ1Q7d0JBQ0UsT0FBTyxFQUFFLGlCQUFpQjt3QkFDMUIsV0FBVyxFQUFFLFVBQVUsQ0FBQyxHQUFHLEVBQUUsQ0FBQyx1QkFBdUIsQ0FBQzt3QkFDdEQsS0FBSyxFQUFFLElBQUk7cUJBQ1o7aUJBQ0Y7O2FBQ0Y7Ozs7eUJBR0UsS0FBSzsyQkFDTCxLQUFLO3NCQUNMLEtBQUs7c0JBQ0wsS0FBSzswQkFDTCxLQUFLO29CQUNMLEtBQUs7dUJBQ0wsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIGZvcndhcmRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IsIE5HX1ZBTFVFX0FDQ0VTU09SIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xyXG5pbXBvcnQgeyBMcERhdGUgfSBmcm9tICdscC1vcGVyYXRpb25zJztcclxuXHJcbkBDb21wb25lbnQoe1xyXG4gIHNlbGVjdG9yOiAnbHAtZGF0ZS1zZWxlY3RvcicsXHJcbiAgdGVtcGxhdGVVcmw6ICcuL2xwLWRhdGUtc2VsZWN0b3IuY29tcG9uZW50Lmh0bWwnLFxyXG4gIHN0eWxlVXJsczogWycuL2xwLWRhdGUtc2VsZWN0b3IuY29tcG9uZW50LnNjc3MnXSxcclxuICBwcm92aWRlcnM6IFtcclxuICAgIHtcclxuICAgICAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXHJcbiAgICAgIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IExwRGF0ZVNlbGVjdG9yQ29tcG9uZW50KSxcclxuICAgICAgbXVsdGk6IHRydWUsXHJcbiAgICB9XHJcbiAgXVxyXG59KVxyXG5leHBvcnQgY2xhc3MgTHBEYXRlU2VsZWN0b3JDb21wb25lbnQgaW1wbGVtZW50cyAgQ29udHJvbFZhbHVlQWNjZXNzb3Ige1xyXG5cclxuICBASW5wdXQoKSBkYXRlRm9ybWF0OiBzdHJpbmdcclxuICBASW5wdXQoKSBzZWxlY3RlZERhdGU6IERhdGUgXHJcbiAgQElucHV0KCkgbWluRGF0ZTogRGF0ZVxyXG4gIEBJbnB1dCgpIG1heERhdGU6IERhdGVcclxuICBASW5wdXQoKSBwbGFjZWhvbGRlcjogc3RyaW5nXHJcbiAgQElucHV0KCkgbGFiZWw6IHN0cmluZ1xyXG4gIEBJbnB1dCgpIGRpc2FibGVkOiBib29sZWFuID0gZmFsc2U7XHJcbiAgbW9udGhPcHRpb25zID0gWydqYW51YXJ5JywgJ2ZlYnJ1YXJ5JywgJ21hcmNoJywgJ2FwcmlsJywgJ21heScsICdqdW5lJywgJ2p1bHknLCAnYXVndXN0JywgJ3NlcHRlbWJlcicsICdvY3RvYmVyJywgJ25vdmVtYmVyJywgJ2RlY2VtYmVyJ11cclxuICBjb25zdHJ1Y3RvcigpIHsgfVxyXG4gIHByaXZhdGUgcHJvcGFnYXRlQ2hhbmdlID0gKF86IGFueSkgPT4geyB9O1xyXG4gIHB1YmxpYyB3cml0ZVZhbHVlKGRhdGU6IERhdGUpIHtcclxuICAgIHRoaXMuc2VsZWN0ZWREYXRlID0gZGF0ZTtcclxuICB9XHJcbiAgcHVibGljIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSkgeyB0aGlzLnByb3BhZ2F0ZUNoYW5nZSA9IGZuOyB9XHJcbiAgcHVibGljIHJlZ2lzdGVyT25Ub3VjaGVkKCkgeyB9XHJcbiAgc2V0RGF0ZShkYXRlPzogRGF0ZSwgeWVhcj86IHN0cmluZywgbW9udGg/OiBzdHJpbmcpIHtcclxuICAgIGlmKGRhdGUpe1xyXG4gICAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IGRhdGU7XHJcbiAgICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlKHRoaXMuc2VsZWN0ZWREYXRlKVxyXG4gICAgfWVsc2UgaWYoeWVhci5sZW5ndGggPT09IDQpe1xyXG4gICAgICB0aGlzLnNlbGVjdGVkRGF0ZSA9IG5ldyBEYXRlKE51bWJlcih5ZWFyKSwgTnVtYmVyKG1vbnRoKSwgMSwgMCwgMCwgMCwgMCk7XHJcbiAgICAgIHRoaXMucHJvcGFnYXRlQ2hhbmdlKHRoaXMuc2VsZWN0ZWREYXRlKVxyXG4gICAgfVxyXG4gIH1cclxuICBtb250aFZhbHVlKG1vbnRoOiBzdHJpbmcpIHtcclxuICAgIHJldHVybiBMcERhdGUubW9udGhWYWx1ZShtb250aClcclxuICB9XHJcblxyXG59XHJcbiJdfQ==