import { Directive, forwardRef, ElementRef, Renderer2, HostListener, NgModule } from '@angular/core';
import { NG_VALUE_ACCESSOR } from '@angular/forms';

import * as ɵngcc0 from '@angular/core';
class LpInputTrimmerDirective {
    constructor(el, renderer) {
        this.el = el;
        this.renderer = renderer;
        this.propagateChange = (_) => { };
    }
    onChange(value) {
        this.propagateChange(value.trim());
    }
    writeValue(val) {
        const value = val == null ? '' : val;
        this.renderer.setProperty(this.el.nativeElement, 'value', value);
    }
    registerOnChange(fn) {
        this.propagateChange = fn;
    }
    registerOnTouched() { }
}
LpInputTrimmerDirective.ɵfac = function LpInputTrimmerDirective_Factory(t) { return new (t || LpInputTrimmerDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
LpInputTrimmerDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LpInputTrimmerDirective, selectors: [["", "lpInputTrimmer", ""]], hostBindings: function LpInputTrimmerDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("input", function LpInputTrimmerDirective_input_HostBindingHandler($event) { return ctx.onChange($event.target.value); });
    } }, features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: NG_VALUE_ACCESSOR,
                useExisting: forwardRef(() => LpInputTrimmerDirective),
                multi: true
            }])] });
LpInputTrimmerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
LpInputTrimmerDirective.propDecorators = {
    onChange: [{ type: HostListener, args: ['input', ['$event.target.value'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LpInputTrimmerDirective, [{
        type: Directive,
        args: [{
                selector: '[lpInputTrimmer]',
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => LpInputTrimmerDirective),
                        multi: true
                    }]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc0.Renderer2 }]; }, { onChange: [{
            type: HostListener,
            args: ['input', ['$event.target.value']]
        }] }); })();

class LpInputTrimmerModule {
}
LpInputTrimmerModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: LpInputTrimmerModule });
LpInputTrimmerModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function LpInputTrimmerModule_Factory(t) { return new (t || LpInputTrimmerModule)(); }, imports: [[]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(LpInputTrimmerModule, { declarations: [LpInputTrimmerDirective], exports: [LpInputTrimmerDirective] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LpInputTrimmerModule, [{
        type: NgModule,
        args: [{
                declarations: [LpInputTrimmerDirective],
                imports: [],
                exports: [LpInputTrimmerDirective]
            }]
    }], null, null); })();

/*
 * Public API Surface of lp-input-trimmer
 */

/**
 * Generated bundle index. Do not edit.
 */

export { LpInputTrimmerDirective, LpInputTrimmerModule };

//# sourceMappingURL=lp-input-trimmer.js.map